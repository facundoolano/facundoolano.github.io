---
layout: post
title: Las increíbles aventuras del señor tijeras
excerpt: Quiero hacer el ejercicio borgeano de fingir que un lenguaje existe y describirlo brevemente.
thumbnail-img: assets/img/funscript.jpg
date: 2020-09-19 11:54:47
tags: [programación]
---

<p>
Este post va a ser un pastiche de <a href="https://facundoolano.wordpress.com/2016/12/09/this-is-unfortunate-and-were-stuck-with-it-forever/">uno anterior</a>, de la época en que programaba cotidianamente en JavaScript.
Aquella vez empecé por citar a Douglas Crockford en la necesidad de elegir un subconjunto de la funcionalidad (<i>The Good Parts</i>)
para sacar lo mejor del lenguaje. Después de publicado el libro de Crockford, JavaScript creció, se convirtió en un lenguaje
diseñado "por comité", sumó mucha más funcionalidad (buena y mala) pero no retiró ninguna de las partes "feas", porque
romper la compatibilidad es un lujo que JavaScript no puede darse. En fin, el problema original se acentuó:
JavaScript es inconsistente y hace falta elegir un subconjunto de sus características para poder usarlo
coherentemente<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>.
</p>

<p>
Aquel post lo terminé diciendo que yo tenía mi subset "preferido" y que si pudiera romper la compatibilidad
hacia atrás y hacer dos o tres pequeños cambios de sintaxis, podía incluso soñar un nuevo lenguaje que,
sin alejarse demasiado del original, se ajustara mejor a mis preferencias. Ahora quiero hacer el ejercicio borgeano de fingir que ese
otro lenguaje existe y describirlo brevemente.
</p>

<p>
El lenguaje se llama FunScript<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> y por comodidad voy a asumir como base <a href="https://www.w3schools.com/js/js_versions.asp">ECMAScript 5</a>, es decir JavaScript
como lo conocíamos hasta el 2014, antes de que empiecen a "arreglarlo". La idea no es llegar a mi lenguaje ideal
(que no tengo idea de cómo sería), sino ver cuánto se puede mejorar retirando elementos o reemplazándolos con
alternativas más sencillas.
</p>

<div id="outline-container-org56e570c" class="outline-2">
<h2 id="org56e570c">JavaScript: las partes nobles</h2>
<div class="outline-text-2" id="text-org56e570c">
<p>
Voy a empezar por recortar cosas con total impunidad y sin dar explicaciones:
</p>

<ul class="org-ul">
<li>Las sentencias no necesitan ser terminadas con <code>;</code>.</li>
<li><code>NaN</code> y <code>Infinity</code> se van.
<ul class="org-ul">
<li>En consecuencia, las divisiones por cero producen un error.</li>
</ul></li>
<li>No hay más <i>type coercion</i>. Es decir que <code>1 + '2'</code> es un error.
<ul class="org-ul">
<li>En consecuencia, <code>==</code> y <code>!=</code> funcionan como se espera y se puede prescindir de <code>===</code> y <code>!==</code>.</li>
</ul></li>
<li>Los operadores booleanos C-like (<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>) son reemplazados por sus equivalentes en inglés <code>and</code>, <code>or</code> y <code>not</code>.</li>
<li><code>new</code> y <code>this</code> se van.</li>
<li><code>null</code> se va, <code>undefined</code> se queda<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>.</li>
</ul>

<p>
No está muy lejos de las ideas de <a href="https://archive.org/details/javascriptgoodpa00croc_0/mode/2up">The Good Parts</a> y <a href="https://es.slideshare.net/JSFestUA/js-fest-2018-douglas-crockford-the-better-parts">The Better Parts</a>. Ahora que terminé con la <i>higienización</i> pasemos
a los cambios.
</p>
</div>
</div>

<div id="outline-container-orgfc7eb7f" class="outline-2">
<h2 id="orgfc7eb7f">Funciones</h2>
<div class="outline-text-2" id="text-orgfc7eb7f">
<p>
Las funciones se definen con el keyword <code>fun</code> en vez de <code>function</code> y devuelven la última expresión
de su bloque<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup>:
</p>

<div class="org-src-container">
<pre class="src src-javascript">fun isEven(number) {
  number % 2 == 0
}
</pre>
</div>

<p>
Admito que este cambio es un poco frívolo, pero tiene algunas ventajas: al ser más corto, el keyword <code>fun</code>
resulta menos molesto de usar como parámetro, es decir: a nadie se le va a ocurrir la necesidad de introducir
nueva sintaxis para las funciones anónimas:
</p>

<div class="org-src-container">
<pre class="src src-javascript">isOdd = fun (number) {
  not isEven(number)
}
</pre>
</div>

<p>
Por otro lado, este keyword nos da la excusa perfecta para nombrar al lenguaje FunScript, por no mencionar que es de público conocimiento que leer la palabra <code>fun</code> con frecuencia libera endorfinas.
</p>

<p>
Si se quiere hacer un <i>early return</i>, se puede usar la keyword explícitamente:
</p>

<div class="org-src-container">
<pre class="src src-javascript">fun evenOrOdd (number) {
  <span style="color: #0000FF;">if</span> isEven(number) {
    <span style="color: #0000FF;">return</span> <span style="color: #008000;">"even"</span>
  }
  <span style="color: #008000;">"odd"</span>
}
</pre>
</div>

<p>
Aunque, ya que estamos, el <code>if</code> es una expresión:
</p>

<div class="org-src-container">
<pre class="src src-javascript">fun evenOrOdd (number) {
  <span style="color: #0000FF;">if</span> isEven(number) {
    <span style="color: #008000;">"even"</span>
  } <span style="color: #0000FF;">else</span> {
    <span style="color: #008000;">"odd"</span>
  }
}

evenOrOdd(1) <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">"odd"</span>
evenOrOdd(2) <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">"even"</span>
</pre>
</div>

<p>
De las versiones nuevas de JavaScript me voy a robar <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters">rest</a> y <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters">default</a> parameters:
</p>

<div class="org-src-container">
<pre class="src src-javascript">fun sum (...numbers) {
  numbers.reduce(fun (number, acc) {
    acc + number
  })
}

sum(1) <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">1</span>
sum (1, 2, 3) <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">6</span>

fun multiply (a, b=1) {
  a * b
}

multiply(3) <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">3</span>
multiply(3, 2) <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">6</span>
</pre>
</div>

<p>
Pero a cambio elimino <code>arguments</code>, y los llamados a funciones con un número de parámetros distinto
al declarado en la firma produce un error:
</p>

<div class="org-src-container">
<pre class="src src-javascript">multiply(3, 3, 3) <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">TypeError: one() takes no arguments (1 given)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org49ad347" class="outline-2">
<h2 id="org49ad347">Variables y scope</h2>
<div class="outline-text-2" id="text-org49ad347">
<p>
De Rust me voy a robar la idea de que los bindings son inmutables a menos que
se explicite lo contrario. Es decir que por default las asignaciones funcionan como
<code>const</code> en ES6:
</p>

<div class="org-src-container">
<pre class="src src-javascript">age = 3
olderAge = age + 3
age = 10 <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">TypeError: Assignment to constant variable.</span>
</pre>
</div>

<p>
Para definir variables se usa el keyword <code>var</code>, aunque tengan <i>block scope</i>, es decir
que funcionan como <code>let</code> en ES6:
</p>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">newAge</span> = 3
newAge = 10 <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">ok</span>
</pre>
</div>

<p>
FIXME arreglar el ejemplo anterior para ilustrar el punto del scope
</p>

<p>
TODO los argumentos de las funciones son bindings inmutables
</p>
</div>
</div>

<div id="outline-container-org8c3b337" class="outline-2">
<h2 id="org8c3b337">Arrays y loops</h2>
<div class="outline-text-2" id="text-org8c3b337">
<ul class="org-ul">
<li>Más o menos lo mismo, pero sin las operaciones mutables.</li>
<li>Ejemplo push (pop?)</li>
<li></li>
</ul>

<p>
Una de las cosas que más me gustan de JavaScript son las "high-order functions" del Array.
map, reduce, forEach, filter y find. Con esas funciones y recursión deberíamos poder prescindir de
todas las keywords de loops.
</p>

<p>
No hay for of / for in
</p>
<pre class="example">

</pre>

<p>
tampoco hay for estilo C. Usar Array.range() en su lugar
</p>
<pre class="example">

</pre>

<p>
Ni tampoco while/do while
</p>
</div>
</div>

<div id="outline-container-org6c92d89" class="outline-2">
<h2 id="org6c92d89">Objetos</h2>
<div class="outline-text-2" id="text-org6c92d89">
<ul class="org-ul">
<li>funcionan como maps/dicts en otros lenguajes</li>
<li>las keys pueden ser de cualquier tipo</li>
<li>si son strings se pueden acceder usando dot notation</li>
<li>No existe "this" ni prototypes. Pero el objeto puede tener métodos seteando funciones a sus campos, y con closures se puede llevar un estado interno:</li>
</ul>

<div class="org-src-container">
<pre class="src src-javascript">fun Counter () {
  <span style="color: #0000FF;">var</span> <span style="color: #BA36A5;">value</span> = 0
  {
    inc: fun () { value += 1 },
    dec: fun () { value -= 1 },
    value: fun () { value }
  }
}

c = Counter()
c.value() <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">0</span>
c.inc() <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">1</span>
c.inc() <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">2</span>
c.dec() <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">1</span>
</pre>
</div>

<p>
// FIXME tiene sentido esto?
</p>
<ul class="org-ul">
<li>al igual que otros valores, son inmutables por default, y la inmutabilidad no es solo de la variable si no del objeto en sí mismo</li>
<li>si los definimos como var podemos mutarlos</li>
<li>pero al pasarlos por funciones son necesariamente inmutables</li>
</ul>
</div>
</div>

<div id="outline-container-org0635805" class="outline-2">
<h2 id="org0635805">Etcétera</h2>
</div>

<div id="outline-container-org86552db" class="outline-2">
<h2 id="org86552db">Sets (FIXME sacar)</h2>
<div class="outline-text-2" id="text-org86552db">
<p>
Los sets no tienen sintaxis especial, lo que sí es importante es que soporten operaciones de conjuntos.
Parece una obviedad, pero la última vez que chequeé no era el caso en la implementación de JavaScript.
</p>

<div class="org-src-container">
<pre class="src src-javascript">set1, set2 = Set([1, 2]), Set([1, 3])
set1.union(set2) <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">Set([1, 2, 3])</span>
set1.difference(set2) <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">Set([2])</span>
set1.intersection(set2) <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">Set([1])</span>
</pre>
</div>

<p>
Estuve tentado de sobrecargar los operadores <code>+</code>, <code>-</code> y <code>and</code> como alternativa a esos métodos, pero ante la duda, <i>less is more</i>.
</p>
</div>
</div>

<div id="outline-container-org7e7fe75" class="outline-2">
<h2 id="org7e7fe75">notas</h2>
<div class="outline-text-2" id="text-org7e7fe75">
<p>
<a href="https://ramdajs.com/">https://ramdajs.com/</a>
<a href="https://learnxinyminutes.com/docs/javascript/">https://learnxinyminutes.com/docs/javascript/</a>
TODO repasar el "catálogo" de js the good parts
<a href="https://es.slideshare.net/JSFestUA/js-fest-2018-douglas-crockford-the-better-parts">https://es.slideshare.net/JSFestUA/js-fest-2018-douglas-crockford-the-better-parts</a>
</p>

<ul class="org-ul">
<li>Como tal todo lo que sigue es altamente inchequeable y posiblemente no haya pensado a fondo todas las consecuencias.</li>
</ul>
</div>
</div>
<div id="footnotes">
<!--h2 class="footnotes">Nota al pie de p&aacute;gina: </h2-->
<h3 class="footnotes">Notas: </h3>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
Supongo que posiblemente este sea un problema ya resuelto en el ecosistema actual de JavaScript, que desconozco. Pero como yo me quedé con la película 2007-2017 del lenguaje, voy a seguir adelante con el razonamiento.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
Para este ejercicio podemos ignorar alegremente el hecho de que <a href="https://github.com/ZachBray/FunScript">ya existe un lenguaje con ese nombre</a>.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
Sé que hay cierto consenso en que tener un valor indefinido trae consecuencias indeseables, pero para ser sincero no es una discusión sobra la que no me interioricé, así que simplemente voy a reincidir en el error de todos los lenguajes que usé.
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
En estos ejemplos uso <code>isEven</code> y <code>isOdd</code> a modo ilustrativo. Desde luego que en un proyecto real, aprovechando que FunScript es completamente interoperable con JavaScript, aprovecharía los paquetes <a href="https://www.npmjs.com/package/is-even">is-even</a> y <a href="https://www.npmjs.com/package/is-odd">is-odd</a> en vez de reinventar la rueda.
</p></div></div>


</div>
</div>
