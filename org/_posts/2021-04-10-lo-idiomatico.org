#+PROPERTY: header-args :eval never-export
#+OPTIONS: toc:nil num:nil
#+LANGUAGE: es
#+BEGIN_EXPORT html
---
layout: post
title: "Lo idiomático"
date: 2021-04-10 14:47:39
tags: [programación]
---
#+END_EXPORT

La semana pasada circuló [[https://github.com/josevalim/nested-data-structure-traversal][un repositorio de José Valim]] que planteaba un problema sencillo de programación (recorrer y "anotar" una estructura de datos anidada) e invitaba a enviar soluciones usando distintos lenguajes. Fue simpático ver cómo crecían las contribuciones con el correr de las horas.

El ejercicio me pareció interesante porque el problema es suficientemente fácil como para entenderlo y encontrarle una solución rápidamente y después divagar indefinidamente sobre las distintas formas de expresarla. En particular, me entretuve pensando cómo cambiaría mi propia solución según cuál de los lenguajes que frecuento usara en cada caso. Abajo transcribo el proceso. Para más contexto, sugiero leer la [[https://github.com/josevalim/nested-data-structure-traversal#the-problem][descripción del problema]]. El código del que extraje los ejemplos siguientes se puede encontrar acá.
# FIXME subir a repo

** Python
La solución que escribí intuitivamente en Python es casi idéntica al [[https://github.com/josevalim/nested-data-structure-traversal/blob/bce81f759dcb4c1efa113e3155520099da7cb300/python/for-in.py#L28-L42][ejemplo provisto en el repositorio]], lo que era esperable porque tendría que haber forzado las cosas para llegar a algo distinto:

#+begin_src python
section_position = 1
lesson_position = 1
for section in sections:
    section["position"] = section_position
    section_position += 1

    if section["reset_lesson_position"]:
        lesson_position = 1

    for lesson in section["lessons"]:
        lesson["position"] = lesson_position
        lesson_position += 1

print(sections)
#+end_src

Encuentro que Python minimiza la distancia entre lo que pienso y termino por escribir. Supongo que se debe en parte a la expresividad del lenguaje pero también a que la forma en que aprendí a razonar los algoritmos cuando estaba empezando a programar se ajusta bastante al estilo imperativo que fomenta Python.

Para ser justo en las comparaciones con los otros lenguajes, voy a agregar algunas restricciones: el código no puede estar suelto en el módulo, ensuciando el scope global, sino que hay que agruparlo en funciones; y la función no puede mutar la estructura de input sino que tiene que construir una nueva:
#+begin_src python
def traverse(sections):
    result = []
    section_position = 1
    lesson_position = 1
    for section in sections:
        section = {**section, "position": section_position}
        section_position += 1

        if section["reset_lesson_position"]:
            lesson_position = 1

        lessons = []
        for lesson in section["lessons"]:
            lesson = {**lesson, "position": lesson_position}
            lesson_position += 1
            lessons.append(lesson)

        section[lessons] = lessons
        result.append(section)

    return result
#+end_src

** Erlang
La implementación en Erlang, donde los datos son inmutables y no hay sentencias iterativas, me requiere un poco más de esfuerzo mental, aunque con los años se volvió relativamente intuitivo pensar el problema en forma recursiva.

Sé que voy a necesitar una función que procese un elemento de la lista a la vez...
#+begin_src erlang
traverse_sections([Section | Rest], % ...
#+end_src

...que voy a tener que acumular los resultados en otra lista y llamar a la misma función con el resto de las secciones...

#+begin_src erlang
traverse_sections([Section | Rest], Output % ...
    %% ...
    traverse_sections(Rest, [SectionWithPositions | Output], %....
#+end_src

...y que al terminar de procesar las secciones voy a tener que invertir la lista con los resultados, para preservar el orden original:

#+begin_src erlang
traverse_sections([Section | Rest], Output % ...
    %% ...
    traverse_sections(Rest, [SectionWithPositions | Output], %....
traverse_sections([], Output, % ...
    lists:reverse(Output).
#+end_src

La primera versión que funcionó me quedó así:

#+begin_src erlang
traverse_sections([Section | Rest], Output, SectionPosition, LessonPositon) ->
    {Lessons, ActualLessonPosition} =
        case Section of
            #{lessons := Lessons, reset_lesson_position := true} -> {Lessons, 1};
            #{lessons := Lessons} -> {Lessons, LessonPositon}
        end,

    {LessonsWithPostions, NextLessonPosition} =
        traverse_lessons(Lessons, [], ActualLessonPosition),
    SectionWithPositions = Section#{position => SectionPosition,
                                    lessons => LessonsWithPostions},

    traverse_sections(Rest, [SectionWithPositions | Output], SectionPosition + 1, NextLessonPosition);
traverse_sections([], Output, _, _) ->
    lists:reverse(Output).

traverse_lessons([Lesson | Rest], Output, LessonPosition) ->
    LessonWithPosition = Lesson#{position => LessonPosition},
    traverse_lessons(Rest, [LessonWithPosition | Output], LessonPosition + 1);
traverse_lessons([], Output, LastLessonPosition) ->
    {lists:reverse(Output), LastLessonPosition}.
#+end_src

Bastante más engorroso que la versión en Python. Prestando un poco de atención, el ~case~ en la primera cláusula me huele mal: en primer lugar porque está haciendo dos cosas a la vez (extraer la lista de lecciones y decidir si se debe resetar la posición), en segundo lugar porque suelo preferir extraer los ~case~ a funciones auxiliares con pattern-matching en sus argumentos. El resultado:

#+begin_src erlang
traverse_sections([Section | Rest], Output, SectionPosition, LessonPosition) ->
    #{lessons := Lessons, reset_lesson_position := ResetPosition} = Section,

    {LessonsWithPostions, NextLessonPosition} =
        traverse_lessons(Lessons, LessonPosition, ResetPosition),
    SectionWithPositions = Section#{position => SectionPosition,
                                    lessons => LessonsWithPostions},

    traverse_sections(Rest, [SectionWithPositions | Output], SectionPosition + 1, NextLessonPosition);
traverse_sections([], Output, _, _) ->
    lists:reverse(Output).

traverse_lessons(Lessons, LessonPosition, _Reset=false) ->
    traverse_lessons(Lessons, [], LessonPosition);
traverse_lessons(Lessons, _LessonPosition, _Reset=true) ->
    traverse_lessons(Lessons, [], 1);

traverse_lessons([Lesson | Rest], Output, LessonPosition) ->
    LessonWithPosition = Lesson#{position => LessonPosition},
    traverse_lessons(Rest, [LessonWithPosition | Output], LessonPosition + 1);
traverse_lessons([], Output, LastLessonPosition) ->
    {lists:reverse(Output), LastLessonPosition}.
#+end_src

El código queda menos anidado, lo que considero un indicio de que el cambio es positivo.

La misma solución se podría reescribir usando [[https://learnyousomeerlang.com/higher-order-functions][funciones de orden superior]], en este caso ~lists:foldl/3~, en vez de aplicar recursión "a mano".

#+begin_src erlang
traverse_sections(Sections) ->
    {Output, _, _} =
        lists:foldl(
          fun (Section, {Output, SectionPosition, LessonPosition}) ->
                  #{lessons := Lessons, reset_lesson_position := ResetPosition} = Section,
                  {LessonsWithPostions, NextLessonPosition} =
                      traverse_lessons(Lessons, LessonPosition, ResetPosition),
                  SectionWithPositions = Section#{position => SectionPosition,
                                                  lessons => LessonsWithPostions},
                  {[SectionWithPositions | Output], SectionPosition + 1, NextLessonPosition}
          end, {[], 1, 1}, Sections),
    lists:reverse(Output).
#+end_src

Si bien son menos líneas de código, esta opción no me termina de convencer: el código resulta más anidado, demasiado denso. Si quisiera extraer la función anónima del ~foldl~ y darle su propio nombre, tampoco sería satisfactorio:

#+begin_src erlang
traverse_sections(Sections) ->
    {Output, _, _} =
        lists:foldl(fun traverse_section/2, {[], 1, 1}, Sections),
    lists:reverse(Output).

traverse_section(Section, {Output, SectionPosition, LessonPosition}) ->
    #{lessons := Lessons, reset_lesson_position := ResetPosition} = Section,
    {LessonsWithPostions, NextLessonPosition} =
        traverse_lessons(Lessons, LessonPosition, ResetPosition),
    SectionWithPositions = Section#{position => SectionPosition,
                                    lessons => LessonsWithPostions},
    {[SectionWithPositions | Output], SectionPosition + 1, NextLessonPosition}.
#+end_src

Encuentro que estas funciones "reductoras" son un poco confusas cuando se las separa del llamado a ~foldl~: se oscurece la justificación para empaquetar los argumentos en una tupla (~{Output, SectionPosition, LessonPosition}~) y al llamar al ~foldl~ nos vemos obligados a descartar elementos del resultado (~{Output, _, _}~). Desde ya que todo esto está bien adentrado en el territorio del gusto personal; ninguna de las opciones anteriores me parece extravagante, todas podrían calificar de /idiomáticas/.

** Lo (no) idiomático
# python con lambdas

# qué nos impide intentar las mismas soluciones de Erlang en Python?
# más allá de que faltan features: pattern matching, tail call optimization

# python con reduce

# erlang con counters

# del repo: elixir con ets, clojure con atoms

# ¿Qué nos lo impide? la empatía, la vergüenza. el respeto por el prójimo. Los usos y costumbres. La honestidad intelectual. Lo idiomático.

# Creo que existe el estilo en programación, entendido como las preferencias, los rasgos personales de cada programación a la hora de expresar la
# solución a un problema. Existe y es de las cosas que enriquecen al oficio, pero hay que usarlo con moderación.

# Hablando de proyectos profesionales, yo suscribo a la idea de que el estilo apropiado es cualquier estilo preexistente en el código sobre el que vamos a trabajar.
# Pero a veces no hay código preexistente o no impone un estilo sobre lo que vamos a escribir, o bien lo consideramos
# inadecuado y nos disponemos a modificarlo.
# En estos casos hay que apelar a lo idiomático, es decir, usar la herramienta en forma convencional,
# no exigir un esfuerzo innecesario a quien tenga que leer lo que escribamos
# solo dentro de esos límites me parece aceptable dar rienda suelta a la preferencia personal.

# Es cierto que postular que esto o aquello es idiomático es meterse en un terreno pantanoso,
# es difícil no convencerse de que el código idiomático es el códig que a mí me parece bien.
# Salvo en casos muy concretos, lo idiomático no está escrito; refiere a convenciones, a un sentido común discutible,
# sujeto a interpretación y a cambios en el tiempo. <No queda más que ser autocrítico:
# ver el código con los ojos del otro, que el código sea visto por otros ojos.>

** Posdata: JavaScript
¿Existe lo idiomático en JavaScript, un lenguaje que es tantos lenguajes y que está en flujo constante? No voy a repetir lo que ya puse en otro post, pero seguramente hay ciertos consensos sobre lo que /no/ se debe hacer. Lo que es decir que uno queda bastante librado al propio estilo o, en todo caso, a un estilo consensuado en equipo o en comunidad.

Si bien podría escribir una solución casi idéntica a la de Python[fn:1]...

#+begin_src javascript
function traverse(sections) {
  let result = [];
  let lessonPosition = 1;

  for (let i = 0; i < sections.length; i++) {
    let section = sections[i];

    if (section.reset_lesson_position) {
      lessonPosition = 1;
    }

    const lessons = [];
    for (let j = 0; j < section.lessons.length; j++) {
      let lesson = section.lessons[j];
      lesson = Object.assign({position: lessonPosition}, lesson);
      lessons.push(lesson);
      lessonPosition++;
    }

    section = Object.assign({}, section, {position: i + 1, lessons});
    result.push(section);
  }

  return result;
}
#+end_src

...en mi corazón JavaScript siempre va a ser un lenguaje funcional (/the first lambda language to go mainstream/):

#+begin_src javascript
function traverse(sections) {
  let lessonPosition = 1;
  return sections.map(function (section, i) {

    if (section.reset_lesson_position) {
      lessonPosition = 1;
    }

    const lessons = section.lessons.map(function (lesson) {
      lesson = {...lesson, position: lessonPosition};
      lessonPosition++;
      return lesson;
    });

    return {...section, lessons, position: i + 1};
  }, []);
}
#+end_src

Con un poco de liberalidad me permito mutar la variable externa ~lessonPosition~ y así cambiar lo que sería un ~reduce~ por un ~map~,
resultando la que probablemente sea la más sencilla de todas las implementaciones que mostré.

Claro que todo se puede llevar demasiado lejos. Durante un tiempo tuve cierta fanatización con la biblioteca [[https://ramdajs.com/][Ramda.js]] y empecé a producir un código que puede gustar o no, pero ciertamente no es idiomático. El mejor es ejemplo es [[https://github.com/facundoolano/aso/blob/master/lib/visibility.js][mi paquete de App Store Optimization]]: la escribí completamente en términos de transformaciones de datos con Ramda y el resultado, para bien o para mal, fue que logré que todo el mundo se abstuviera para siempre de mandar un Pull-Request a ese repositorio.

** Posdata: Ejercicios de estilo
Hay un libro que sigue una premisa parecida al repositorio de José Valim. Se llama [[https://www.routledge.com/Exercises-in-Programming-Style/Lopes/p/book/9780367350208][Exercises in programming style]], inspirado por
el [[https://en.wikipedia.org/wiki/Exercises_in_Style][libro de ejercicios de estilo]] de Raymond Queneau. Ahí se usa Python no en forma idiomática sino como /lingua franca/ para resolver un mismo problema
de muchas maneras posibles y en el proceso hacer un repaso de la historia de la programación.

#+begin_quote
In the universe of all things a good programmer must know, I see collections of programming styles as being as important as any collection of data structures and algorithms, but with a focus on human effects rather than on computing effects. Programs convey information not just to the computers but, more importantly, to the people who read them. As with any form of expression, the consequences of *what* is being said are shaped and influenced by *how* they are being said. An advanced programmer needs not be able to just write correct programs that perform well; he/she needs to be able to choose appropriate styles for expressing those programs for a variety of purposes.
#+end_quote

Los ejercicios se pueden ver [[https://github.com/crista/exercises-in-programming-style][en este repositorio]].

* Footnotes

[fn:1] En el repositorio de Valim hay una [[https://github.com/josevalim/nested-data-structure-traversal/blob/bce81f759dcb4c1efa113e3155520099da7cb300/javascript/for_of.js][solución imperativa]] bastante más limpia usando ~for ... of~.
