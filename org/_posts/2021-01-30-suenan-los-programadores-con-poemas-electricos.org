#+OPTIONS: toc:nil num:nil
#+LANGUAGE: es
#+BEGIN_EXPORT html
---
layout: post
title: "¿Sueñan los programadores con poemas eléctricos?"
date: 2021-01-30 13:43:39
tags: [programación, software, literatura]
---
#+END_EXPORT

Alguna vez me dijeron que era un /inmenso pajero/ por proponer que la programación es una rama de la literatura[fn:1]. No voy a negar las fuertes notas ahumadas de la frase, pero sí creo que tiene puntos de contacto con la escritura, y que puede ser útil observarlos.

La programación se ejecuta mediante la palabra escrita; está más o menos aceptado que el código se escribe tanto para la computadora como para otros humanos; que (excepto en Perl) el código se lee muchas más veces de las que se lo escribe. Partiendo de ahí, hace falta un pequeñísimo salto para coincidir en que /antes que decirle a la computadora lo que tiene que hacer, la tarea de un programador es explicarle a otro ser humano lo que queremos que la computadora haga/[fn:2].

Si aceptamos esto, ya no alcanza con preocuparnos por la "legibilidad" ---evitar el código excesivamente denso o anidado, preferir nombres representativos--- sino que tenemos que orientar nuestros esfuerzos para comunicar una idea con la mayor eficacia posible.

#+BEGIN_CENTER
\ast{} \ast{} \ast{}
 #+END_CENTER

El escritor de ficción tiene la tarea improbable de equilibrar un sistema infinitamente complejo, tomar decisiones sobre cada elemento y su conjunto: el orden en que ofrece la información y desplega la trama, la longitud y el ritmo de las frases, la manera en que decide intercalar pasajes descriptivos y diálogos, hasta las asociaciones que prevee evocar en su lector con la elección de este o aquel adjetivo. De igual manera el programador dispone de toda una paleta de instrumentos que pueden servir o conspirar contra la tarea de expresar las intenciones de su programa: la estructura de directorios y archivos, las interfaces de sus módulos, la longitud de las funciones y el orden en que se las presenta, el uso de comentarios, la decisión de nombrar expresiones y el nombre que se les elige, el estilo con el que se controla el flujo y se manipulan los datos y hasta el lugar donde se colocan los espacios en blanco.

#+BEGIN_CENTER
\ast{} \ast{} \ast{}
 #+END_CENTER

Es un lugar común de los escritores decir que no piensan en sus lectores cuando escriben, que lo hacen para sí mismos, quizás como una manera de demostrar que no hacen concesiones a los intereses del público o del mercado. Pero lo cierto es que todos escribimos para ser leídos, aunque nuestro lector ideal no se corresponda con alguien concreto, aunque todavía no haya nacido; siquiera inconscientemente, la escritura conlleva la construcción de un lector modelo, es decir, un lector imaginario que orienta las elecciones del autor, por ejemplo el nivel de detalle que debe proveer para que el texto sea interpretado[fn:3].

Para un programador profesional, el lector modelo debería aproximar no solo a sus actuales colegas sino a su futuro yo, a cualquier futuro responsable del código, incluso a quien tenga que consultarlo ocasionalmente para conseguir información. ¿Cómo se supone que vayamos a ponernos en los zapatos de este grupo abstracto de personas? No creo que haya un método satisfactorio; lo mejor que se me ocurre es imaginar cuál hubiese sido nuestra experiencia abordando el código con el conocimiento y el contexto que teníamos hace uno, dos, cinco años. No importa cuánto se haga, es imposible que el código sea accesible para todo el mundo; se trata de decidir conscientemente, sin frivolidad, a quién se deja afuera.

A medida que escribimos el código y sobre todo durante la etapa de corrección (cuando el programa ya funciona, el problema está resuelto en nuestra cabeza y podemos reorganizar el código en la forma que mejor comunique la solución), deberíamos hacer el intento de leerlo con los ojos de nuestro lector modelo. ¿Qué va a ver una persona cuando liste el directorio del proyecto o entre a GitHub, cuando lea el README y siga los links que le ofrecemos, cuando abra un archivo y lea su encabezado y las primeras funciones hacia las que tratamos de llamar su atención? ¿Qué tan bien lograremos comunicar nuestra idea a alguien que siga ese camino?

Algunos escritores profesionales tienen acceso a un editor; alguien que puede dar impresiones, intercambiar ideas con el autor, sugerir (o exigir) cambios[fn:4]. Se trata de un lector concreto que complementa al lector modelo de la etapa creativa; creo que este rol se asemeja un poco al del colega que hace un /peer review/ cuando el código todavía está en desarrollo[fn:5].

#+BEGIN_CENTER
\ast{} \ast{} \ast{}
 #+END_CENTER

Algunos autores recomiendan tomar distancia del texto después de escribir el primer borrador, dejarlo descansar por unas semanas en el cajón[fn:6]. Esto les permite retomarlo con una mirada fresca, como si otra persona lo hubiera escrito, detectar problemas que la extrema familiaridad del trabajo diario les había ocultado.

Generalmente, los programadores no podemos permitirnos olvidar el código por dos meses; en la mayoría de los casos queremos usarlo tan rápido como sea posible, o antes. Hay mucho potencial de mejora en el pasaje a producción, mucho más que en la mera distancia con el código. Esto no invalida del todo el método del cajón, sin embargo: para nosotros, pasar el código a producción de alguna manera /es/ dejarlo en el cajón. Si suscribimos a la idea de /Refactoring/, el código nunca está terminado, siempre es una buena idea tomar un programa que funciona y pulirlo, mejorar su estructura; después del desarrollo inicial de un programa, después de ponerlo en uso y corregirlo, cuando consideramos que la funcionalidad es aceptable, podemos olvidarnos del código por un tiempo; podemos volver a él, meses más tarde, evaluarlo con el beneficio de la distancia, encontrar oportunidades de mejora, refactorizar.

* Footnotes

[fn:6] Por ejemplo: [[https://www.pagina12.com.ar/diario/suplementos/libros/subnotas/1823-238-2005-11-13.html][Chéjov]] y [[https://www.businessinsider.com/stephen-king-on-how-to-write-2014-8#20-when-youre-finished-writing-take-a-long-step-back-220][Stephen King]].

[fn:5] Me gustaría una herramienta de GitHub que permitiera presentar los cambios de un pull request en un orden arbitrario, intercalando texto descriptivo, una especie de /literate diffing/.

[fn:1] [[https://www.reddit.com/r/programming/comments/65ct5j/a_pythonist_finds_a_new_home_at_clojure_land/dgau7bp/?utm_source=reddit&utm_medium=web2x&context=3][A pythonist finds a new home at Clojure land]].

[fn:2] [[http://www.literateprogramming.com/knuthweb.pdf][Literate Programming]], de Donald Knuth.

[fn:3] [[https://alvaro-videla.com/2018/05/lector-in-codigo.html#the-model-reader][Lector in Codigo]], de Álvaro Videla.

[fn:4] [[https://www.theparisreview.org/interviews/1760/the-art-of-editing-no-1-robert-gottlieb][The Art of Editing]], entrevista a Robert Gottlieb.
